%%% -*-LaTeX-*-

\chapter{Motivation}

% This is a chapter.  Remember  that there should \emph{always}
% be at least of few lines of prose after each sectional heading:
% failure to do so is a disservice to your readers, and also
% produces incorrect vertical spacing.

\textbf{SweetPea} \cite{annie}, a language for experimental design, attempts to generate approximately uniformly sampled trial sequences by relying on the aid of a SAT-sampler to provide uniformity guarantees. In practice, this approach does not scale to support realistic experimental designs. This thesis presents evidence demonstrating the need for an alternative and investigates other approaches to overcome this problem. These include a different encoding scheme as well as techniques for direct construction of a solution based on its numerical index in the sequence of all solutions. These improvements significantly improve SweetPea's capability to guarantee a uniform sampling of trial sequences.

\section{Introduction}

For any valid design configuration, there exists some set of trial sequences that conform to the design. Typically this set is extremely large, as the size grows factorially in the trial sequence length of the design. The magnitude of the solution space for experimental designs has posed a significant challenge for scientists desiring to conduct unbiased resarch.

At present, scientists patch together different scripts and tools in various ways to generate experiment trial sequences. This method, in addition to being brittle, does not facilitate sharing, nor does it produce unbiased sequences, making it nearly impossible for peers to replicate results. SweetPea provides a high-level declarative language for describing all aspects of an experimental design, providing standard tooling where before there was none. In addition, with the aid of a SAT-sampler, it generates approximately uniformly sampled trial sequences from the space of all sequences conforming to the design. SweetPea is composed of a Python library, which provides the language constructs, and a server that generates and processes the design using a SAT-sampler.

At the highest level, an experimental design is composed of a \textit{block}, whose properties may vary depending on its type. At present, only a single block type is provided by SweetPea, which is the \textit{FullyCrossBlock}. A \texttt{FullyCrossBlock} is composed of a set of \textit{factors}, a set of \textit{constraints}, and a \textit{crossing}. A \textit{factor} is a collection of \textit{levels}, or values to which the factor may be set. In a given trial, each factor takes the value of one of its levels. Levels may be values determined by the designer, or they may be derived from the values of other factors in the design. A \textit{constraint} constrains the experiment in some regard. For example, the designer may wish to prohibit a particular level from being repeated in a trial sequence. Lastly, the \textit{crossing} identifies the factors whose levels should be combined (crossed) in all possible ways in each trial sequence. The output of a design is a set of trial sequences. A single level value from each factor comprises a \textit{trial}.


\section{Current Implementation}

SweetPea works by encoding the experimental design in a boolean satisfiability (also known as SAT) formula. such that any satisfying assignment constitutes a trial sequence that conforms to the design. Currently, a simple positional encoding is used, in which every level of every factor of every trial is represented as a distinct variable.

\subsection{Boolean Satisfiability}

The Boolean satisfiability problem (abbreviated SAT) is the problem of determining whether or not a Boolean formula can be satisfied, or be caused to evaluate to true, by a particular true or false assignment to each of its variables. If a problem can be expressed as a Boolean formula, then techniques from satisfiability theory may be applied to determine whether or not a solution exists to the problem, or to locate a particular solution. Many different SAT solvers exist which accept a Boolean formula as input, and output either that the formula is \textit{unsatisfiable}, or a solution to the formula.

Tools for interacting with SAT formulae typically require the input formula to be in \textit{conjunctive normal form} (abbreviated CNF), which is a form of a Boolean formula with specific properties. A Boolean formula is in conjunctive normal form only when three conditions are met. First, the entire formula must be a conjunction of clauses. Second, each clause consists of an individual variable, or a disjunction of variables. Third, negation may only be applied to individual variables. Any Boolean formula may be expressed in conjunctive normal form, though it usually requires growth in some dimension. SweetPea uses the Tseitin Transformation \cite{tseitin1983complexity} to do this conversion, which has the tightest known bounds on formula length, at the expense of allocating additional variables. A SAT formula contains some number of boolean variables and propositional logic clauses. A selection of true or false for each variable in the formula constitutes an \textit{assignment}. If a given assignment causes the entire formula to be true, then the formula is said to be \textit{satisfied} by that assignment, or more generally, the formula is \textit{satisfiable}. If no such assignment exists, the formula is said to be \textit{unsatisfiable}.

\subsection{Example: Stroop Experiment}

The Stroop test \cite{stroop1935studies} is a well-known design among experimental psychologists in which a subject's reaction time is influenced by perceived conflicts in the trial sequence. For example, a subject may be shown printed words representing colors and asked to read the word. However, some of the time the font color of the word will be different than the printed word itself, leading to a delayed reaction due to the conflict. This design is easily represented in SweetPea as follows:

\begin{verbatim}
color = Factor("color", ["red", "green", "blue"])
text  = Factor("text",  ["red", "green", "blue"])
\end{verbatim}

A \texttt{FullyCrossBlock} with these two factors will yield a sequence of $3 \cdot 3 = 9$ trials. A research may want to constrain the design to ensure that there are never two consective trials in which the color and text are the same, or congruent. Such a constraint requires the addition of another factor:

\begin{verbatim}
congruent = Factor("congruent?", [
    DerivedLevel("yes", WithinTrial(operator.eq, [color, text])),
    DerivedLevel("no",  WithinTrial(operator.ne, [color, text]))
])
\end{verbatim}

With the factor now in place, a constraint may be specified:

\begin{verbatim}
AtMostKInARow(1, ("congruent?", "yes"))
\end{verbatim}

The current encoding scheme will allocate 72 variables to represent each level of each factor in each trial. Additional variables will be allocated to enforce other constraints, such as ensuring that each factor takes only one level in each trial, and requiring that each crossing be present in the sequence. The first step of the encoding can be visualized easily, as demonstrated in Table \ref{tab:encoding_diagram}.

\begin{table}[htb]
  \centering
  \caption{Example of an Encoding Diagram}
\begin{tabular}{|r|c|c|c|c|c|c|c|c|}
\hline
\multicolumn{1}{|l|}{}             & \multicolumn{3}{c|}{Color} & \multicolumn{3}{c|}{Text} & \multicolumn{2}{c|}{Congruent?} \\ \hline
\multicolumn{1}{|l|}{Trial Number} & Red    & Green    & Blue   & Red    & Green   & Blue   & Yes             & No            \\ \hline
1                                  & 1      & 2        & 3      & 4      & 5       & 6      & 7               & 8             \\ \hline
2                                  & 9      & 10       & 11     & 12     & 13      & 14     & 15              & 16            \\ \hline
3                                  & 17     & 18       & 19     & 20     & 21      & 22     & 23              & 24            \\ \hline
4                                  & 25     & 26       & 27     & 28     & 29      & 30     & 31              & 32            \\ \hline
5                                  & 33     & 34       & 35     & 36     & 37      & 38     & 39              & 40            \\ \hline
6                                  & 41     & 42       & 43     & 44     & 45      & 46     & 47              & 48            \\ \hline
7                                  & 49     & 50       & 51     & 52     & 53      & 54     & 55              & 56            \\ \hline
8                                  & 57     & 58       & 59     & 60     & 61      & 62     & 63              & 64            \\ \hline
9                                  & 65     & 66       & 67     & 68     & 69      & 70     & 71              & 72            \\ \hline
\end{tabular}
\label{tab:encoding_diagram}
\end{table}

For example, if variable 68 is true, that corresponds to the level \texttt{red} being selected for the factor \texttt{text} in trial number 9. The encoding will also require variables 69 and 70 to be false in this case, as well as require variable 71 to be equivalent to 65. Once a solution is found, it is then decoded back into the original language of the design as a trial sequence. For more details concerning SweetPea's syntax or the current encoding scheme, the reader is referred to the original paper.

\subsection{One-to-One Correspondence}

In order for the uniformity guarantees of sampling tools to tranlate back into the problem space of the original experiment design, it is critical that the encoding scheme maintain a one-to-one relationship between formula solutions and distinct trial sequences. Without this relationship, it would be possible to uniformly sample solutions to the SAT formula while still introducing bias in the generated trial sequences. For example, if three SAT solutions yielded trial sequence $S_1$, while only one solution yielded trial sequence $S_2$, uniformly distributed solutions to the SAT formula would produce $S_1$ more frequently than $S_2$.

A few observations build our confidence that this correspondance is upheld. First, all factor and level selections, including associated constraints for derived levels, in the original problem space are represented directly in the SAT encoding. Each level of each factor is represented by a unique variable for every trial in the sequence, and clauses are added to the CNF to ensure that variable assignments are consistent with the actual constraints of the problem. Referring back to the example in Table \ref{tab:encoding_diagram}, the levels for the \texttt{Color} factor for trial number 1 are represented by variables 1, 2, and 3 respectively. A popcount circuit is embedded in the SAT formula that requires that exactly one of those variables is set to true. This same circuit is repeated for the \texttt{Color} factor for each of the 9 trials, as well as for all other factors in all 9 trials. Other constraints are also embedded to represent all other rules of the design, including relationships between basic and derived factors, and constraints that require the full spectrum of crossed factor combinations to be represented in the sequence. Because all data from the original design is directly translated into SAT variables and constraints, we believe there is no risk of generating multiple solutions to the formula that represent the same trial sequence.

However, some of these constraints are represented in expressions richer than allowed by CNF, including logical implication. Of necessity, these expressions must be rewritten in an equivalent form using only those primitives allowed by CNF. In order to avoid an exponential explosion in the length of the formula, this rewriting process introduces additional variables to represent repeating clauses. The second observation is that SweetPea applies the Tseytin transformation to do this conversion to CNF, which binds every variable that it introduces to the state of a clause in the original formula. As a result, the number of solutions remains the same, and there is no possibility of underconstrained variables skewing the results.

Lastly, we note that for small designs, we can exhaustively enumerate all possible trial sequences. The number of enumerated sequences matches exactly the result obtained when using a SAT model counter to determine the number of solutions to the SAT formula. Were there not a one-to-one mapping, these figures would disagree.


\section{Problems}

SweetPea sounds panacean, but it has yet to fully realize its objectives. It relies \textit{fully} on a SAT-sampler to approximately uniformly sample some number of solutions to the generated formula. In practice, this works wonderfully for \textit{small} experimental designs, where \textit{small} means designs in which the trial sequence length is less than ten. However, realistic experimental designs are significantly larger, often with trial sequence lengths in the tens or hundreds.

A solution to the formula represents a unique trial \textbf{sequence} in the design. Therefore every possible sequence permutation (so long as it upholds the design constraints) is also a distinct solution. Consequentially, the number of solutions grows factorially in the sequence length. In the above example, the sequence length, denoted $l$, was $9$. Assuming the congruence constraint were removed, there would be $9! = 362,880$ solutions, which is still reasonable. Consider an experiment however in which $l = 36$. The solution count grows to $36! \approx 2^{138}$, which is intractable. As will be seen in chapter 3, it is common for experimental designs to have sequence lengths even larger than 36.

\begin{table}[htb]
  \centering
  \caption{Growth of Solution Space}
\begin{tabular}{|l|r|}
\hline
\multicolumn{1}{|c|}{\textbf{Sequence Length ($l$)}} & \multicolumn{1}{c|}{\textbf{\#SAT ($l!$)}}              \\ \hline
4                                                    & 24                                                      \\ \hline
6                                                    & 720                                                     \\ \hline
9                                                    & 362,880                                                 \\ \hline
12                                                   & 479,001,600                                             \\ \hline
16                                                   & 20,922,789,888,000                                      \\ \hline
20                                                   & 2,432,902,008,176,640,000                               \\ \hline
25                                                   & 15,511,210,043,330,985,984,000,000                      \\ \hline
30                                                   & 265,252,859,812,191,058,636,308,480,000,000             \\ \hline
36                                                   & 371,993,326,789,901,217,467,999,448,150,835,200,000,000 \\ \hline
\end{tabular}
\label{tab:factorial_explosion}
\end{table}

In practice, designs will be constrained, however the constraints only exclude specific patterns in the permutations, therefore the number of solutions remains dominated by $l!$. Clearly, generating all possible solutions is not feasible. We had hoped that a SAT sampler would be able to sample solutions from this space, but in practice this growth rate very quickly overwhelms all tested SAT-samplers. It has been well established that prior SAT-samplers have traded strong uniformity guarantees for scalability \cite{chakraborty_balancing_2014}, and thus were not suitable for even moderately large formulae. Unigen \cite{chakraborty_balancing_2014} contributed two primary advancements to bridge this gap between scalability and uniformity guarantees, but only under certain conditions. Unfortunately, the nature of the formulae generated by SweetPea designs violates these conditions, as the target domain of Unigen, constrained-random verification (CRV), exhibits different characteristics than experimental design.
